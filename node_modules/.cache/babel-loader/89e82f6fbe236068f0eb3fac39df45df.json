{"ast":null,"code":"import { withHandlers, onWillReceiveProps, onDidUpdate, isolate, integrate } from \"reassemble\";\nexport var preventPhantomEvents = isolate(withHandlers(function () {\n  var lastTriggerTime;\n  var lastTriggerTimePerformance;\n  var timeUpdateRequested = false;\n  return {\n    requestTimeUpdate: function requestTimeUpdate() {\n      return function () {\n        timeUpdateRequested = true;\n      };\n    },\n    handleTimeUpdateRequest: function handleTimeUpdateRequest() {\n      return function () {\n        if (timeUpdateRequested) {\n          lastTriggerTime = Date.now();\n\n          if (typeof performance !== \"undefined\" && typeof performance.now !== \"undefined\") {\n            lastTriggerTimePerformance = performance.now();\n          }\n\n          timeUpdateRequested = false;\n        }\n      };\n    },\n    onTransitionEnd: function onTransitionEnd(_a) {\n      var onTransitionEnd = _a.onTransitionEnd;\n      return function (e) {\n        if (!onTransitionEnd) {\n          return;\n        }\n\n        if (e.target !== e.currentTarget) {\n          onTransitionEnd(e);\n          return;\n        } // Skip transitionEnd that comes <= 10ms after (reversing) a transition.\n        // In most cases this came from the previous transition.\n\n\n        var compareWith = lastTriggerTime;\n\n        if (e.timeStamp < 1000000000000 && lastTriggerTimePerformance) {\n          compareWith = lastTriggerTimePerformance;\n        }\n\n        if (e.timeStamp - compareWith <= 10) {\n          return;\n        }\n\n        onTransitionEnd(e);\n      };\n    }\n  };\n}), onWillReceiveProps(function (_a, _b) {\n  var active = _a.active;\n  var nextActive = _b.active,\n      requestTimeUpdate = _b.requestTimeUpdate;\n\n  if (active !== nextActive) {\n    requestTimeUpdate();\n  }\n}), onDidUpdate(function (_a) {\n  var handleTimeUpdateRequest = _a.handleTimeUpdateRequest;\n  return handleTimeUpdateRequest();\n}), integrate(\"onTransitionEnd\"));","map":null,"metadata":{},"sourceType":"module"}